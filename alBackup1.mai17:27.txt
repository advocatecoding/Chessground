import './input.css';
import { useState } from 'react';
import pawnWhite from './images/pawn_white.png'
import bishopWhite from './images/bishop_white.png'
import kingWhite from './images/king_white.png'
import queenWhite from './images/queen_white.png'
import rookWhite from './images/rook_white.png'
import knightWhite from './images/knight_white.png'
import highlighter from "./images/highlighter.png"
import pawnBlack from './images/pawn_black.png';
import bishopBlack from './images/bishop_black.png';
import kingBlack from './images/king_black.png';
import queenBlack from './images/queen_black.png';
import rookBlack from './images/rook_black.png';
import knightBlack from './images/knight_black.png';



function App() {

  const cordY = [8, 7, 6, 5, 4, 3, 2, 1];

  const cordX = [1, 2, 3, 4, 5, 6, 7, 8];

  const whitePieces = [rookWhite, knightWhite, bishopWhite, queenWhite, kingWhite, pawnWhite]

  const blackPieces = [rookBlack, knightBlack, bishopBlack, queenBlack, kingBlack, pawnBlack]

  const [move, setMove] = useState(2);

  const [curMovableFields, setCurMovableFields] = useState([])

  // Geschlagene Figuren speichern 
  const [blackPiecesTaken, setBlackPiecesTaken] = useState([kingBlack])
  const [whitePiecesTaken, setWhitePiecesTaken] = useState([queenWhite])


  const [fields, setFields] = useState({
    11: rookWhite,
    21: knightWhite,
    31: bishopWhite,
    41: queenWhite,
    51: kingWhite,
    61: bishopWhite,
    71: knightWhite,
    81: rookWhite,

    12: pawnWhite,
    22: pawnWhite,
    32: pawnWhite,
    42: pawnWhite,
    52: pawnWhite,
    62: pawnWhite,
    72: pawnWhite,
    82: pawnWhite,

    17: pawnBlack,
    27: pawnBlack,
    37: pawnBlack,
    47: pawnBlack,
    57: pawnBlack,
    67: pawnBlack,
    77: pawnBlack,
    87: pawnBlack,

    18: rookBlack,
    28: knightBlack,
    38: bishopBlack,
    48: queenBlack,
    58: kingBlack,
    68: bishopBlack,
    78: knightBlack,
    88: rookBlack,

  })




  const [pieceIsSelected, setSelectPiece] = useState(false);
  const [currentPiece, setCurrentPiece] = useState(null);

  const showMovableFields = (field) => {
    switch (fields[field]) {

      case pawnWhite:
        var x = parseInt(field[0])
        var y = parseInt(field[1])
        var possibleFields = []

        // Prüfen ob Pawn in der Startposition ist & ob vor ihm eine Figur steht
        var f1 = x + (y + 1).toString()

        var f2 = x + (y + 2).toString()

        // Prüfen ob das Feld leer ist bzw. undefined
        if (fields[f1] === undefined) {
          possibleFields.push(f1)
          if (fields[f2] === undefined) {
            if (y === 2) {
              possibleFields.push(f2)
            }
          }
        }

        // Prüfen ob er Schlagen kann
        var f3 = (x - 1).toString() + (y + 1).toString()
        var f4 = (x + 1).toString() + (y + 1).toString()
        if (blackPieces.includes(fields[f3])) {
          possibleFields.push(f3)
        }
        if (blackPieces.includes(fields[f4])) {
          possibleFields.push(f4)
        }


        highlightMovableFields(possibleFields)
        break;

      case pawnBlack:
        var x = parseInt(field[0])
        var y = parseInt(field[1])
        var possibleFields = []

        // Prüfen ob Pawn in der Startposition ist & ob vor ihm eine Figur steht
        var f1 = x + (y - 1).toString()

        var f2 = x + (y - 2).toString()

        // Prüfen ob das Feld leer ist bzw. undefined
        if (fields[f1] === undefined) {
          possibleFields.push(f1)
          if (fields[f2] === undefined) {
            if (y === 7) {
              possibleFields.push(f2)
            }
          }
        }

        // Prüfen ob er Schlagen kann
        var f3 = (x - 1).toString() + (y - 1).toString()
        var f4 = (x + 1).toString() + (y - 1).toString()
        if (whitePieces.includes(fields[f3])) {
          possibleFields.push(f3)
        }
        if (whitePieces.includes(fields[f4])) {
          possibleFields.push(f4)
        }
        highlightMovableFields(possibleFields)
        break;
      default:
        break;
    }
  }


  const handleClick = (field) => {
    // Prüfen ob noch keine Figur ausgewählt ist
    if (!pieceIsSelected) {
      selectPiece(field)
    } else {
      // Wenn schon eins ausgewählt ist soll er bewegt werden
      movePiece(field)
    }
  }

  const highlightMovableFields = (movableFields) => {
    // Setze die möglichen Felder die besetzt werden können 
    setCurMovableFields(movableFields)

    for (let i = 0; i < movableFields.length; i++) {
      var img = document.createElement("img");
      img.setAttribute("src", highlighter);
      img.setAttribute("class", "highlighter")
      document.getElementById(movableFields[i]).appendChild(img)
    }
  }


  const resetHighlights = () => {
    // Speichert alle Squares und werden danach alle demarkiert  
    var allFields = document.querySelectorAll(".highlighter")
    for (let i = 0; i < allFields.length; i++) {
      allFields[i].remove()
    }
  }

  const selectPiece = (field) => {
    // Prüfen ob weiß dran ist 
    if (move % 2 === 0) {
      if (whitePieces.includes(fields[field])) {
        //movePiece(field)
        showMovableFields(field)
        setSelectPiece(true)
        setCurrentPiece(field)
        //console.log("Figur ausgewählt", field)
      } else {
        return
      }
    } else {
      if (blackPieces.includes(fields[field])) {
        //movePiece(field)
        showMovableFields(field)
        setSelectPiece(true)
        setCurrentPiece(field)
        //console.log("Figur ausgewählt", field)
      } else {
        return
      }
    }
  }

  const movePiece = (newField) => {
    //console.log("wird bewegt nach", newField)

    // Prüfen ob der zu bewegende Square besetzbar ist von der aktuellen Figur 
    if (curMovableFields.includes(newField)) {
      // Geschlagene Figur speichern in der geschlagenen Liste
      const takenPiece = fields[newField] 
      // Schauen ob das besetzte Feld aktuell eine Figur hatte 
      if (takenPiece !== undefined) {
        if (blackPieces.includes(takenPiece)) {
          // Liste erweitern um takenPiece
          setBlackPiecesTaken([...blackPiecesTaken, takenPiece])
        }else {
          setWhitePiecesTaken([...whitePiecesTaken, takenPiece])
        }
      }

      // Neuer Field wird mit der ausgewählten Figur besetzt
      fields[newField] = fields[`${currentPiece}`]
      fields[currentPiece] = undefined
      setFields({ ...fields })
      // Figur wird vom alten Field gelöscht 
      setSelectPiece(false)

      


      resetHighlights()
      setMove(move + 1)
    }
  }


  return (
    <>
      {/** Wer ist an der Reihe?*/}
      <div className='absolute right-8 top-8 h-24 w-24 flex flex-wrap content-center justify-center text-6xl'

        style={move % 2 !== 0 ? { backgroundColor: "black", color: "white" } : { backgroundColor: "white", color: "black" }}>

        {Math.floor(move / 2)}

      </div>


      {/** Feld */}
      <div className="relative grid-cols-8 inline-grid m-auto">
        {cordY.map((number) => {
          if (number % 2 === 0) {
            return cordX.map((letter, index) => {
              let color = ((index) % 2 === 0) ? "bg-teal-900" : "bg-white"
              return (<div className={`w-24 h-24 field ${color}`} id={`${letter}${number}`}
                style={{
                  backgroundImage: "url(" + fields[`${letter}${number}`] + ")",
                  backgroundSize: "cover", cursor: "pointer"
                }}
                onClick={() => handleClick(`${letter}${number}`)}>
              </div>)
            })
          } else {
            return cordX.map((letter, index) => {
              let color = ((index) % 2 === 0) ? "bg-white" : "bg-teal-900"
              return (<div className={`w-24 h-24 field ${color}`} id={`${letter}${number}`}
                style={{
                  backgroundImage: "url(" + fields[`${letter}${number}`] + ")",
                  backgroundSize: "cover", cursor: "pointer"
                }}
                onClick={() => handleClick(`${letter}${number}`)}>
              </div>)
            })
          }
        })
        }

        {/** Geschlagene Figuren am Rand anzeigen */}
        <div className='absolute bottom-0 flex flex-col-reverse -left-10' >
          {
            blackPiecesTaken.map((piece) => {
              return <img className='w-8' src={piece}></img>
            })
          }
        </div>

        <div className='absolute top-0 flex flex-col-reverse -left-10' >
          {
            whitePiecesTaken.map((piece) => {
              return <img className='w-8' src={piece}></img>
            })
          }
        </div>

      </div>
    </>
  );
}

export default App;
